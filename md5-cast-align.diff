From fcb754fffbd3e0b019c6a7d4f638dddaeacc38f1 Mon Sep 17 00:00:00 2001
From: Emerson Knapp <eknapp@amazon.com>
Date: Mon, 3 Jun 2019 18:28:27 -0700
Subject: [PATCH] Fix cast-align warnings in md5.cpp on armhf

View m_in in MD5 as 32-bit instead of 8-bit to ensure proper alignment.

Signed-off-by: Emerson Knapp <eknapp@amazon.com>
---
 src/md5.cpp | 31 ++++++++++++++++---------------
 src/md5.h   |  4 +++-
 2 files changed, 19 insertions(+), 16 deletions(-)

diff --git a/src/md5.cpp b/src/md5.cpp
index eeb940c3..f485096a 100644
--- a/src/md5.cpp
+++ b/src/md5.cpp
@@ -72,6 +72,7 @@ MD5::MD5()
     * The MD5 stuff is written for little endian.
     */
 
+   m_in8           = (UINT8 *)m_in32;
    m_need_byteswap = *(UINT8 *)m_buf != 4;
    m_big_endian    = *(UINT8 *)m_buf == 1;
 }
@@ -108,7 +109,7 @@ void MD5::Update(const void *data, UINT32 len)
    // Handle any leading odd-sized chunks
    if (t)
    {
-      UINT8 *p = (UINT8 *)m_in + t;
+      UINT8 *p = m_in8 + t;
 
       t = 64 - t;
       if (len < t)
@@ -119,9 +120,9 @@ void MD5::Update(const void *data, UINT32 len)
       memcpy(p, buf, t);
       if (m_need_byteswap)
       {
-         reverse_u32(m_in, 16);
+         reverse_u32(m_in8, 16);
       }
-      Transform(m_buf, (UINT32 *)m_in);
+      Transform(m_buf, m_in32);
       buf += t;
       len -= t;
    }
@@ -129,18 +130,18 @@ void MD5::Update(const void *data, UINT32 len)
    // Process data in 64-byte chunks
    while (len >= 64)
    {
-      memcpy(m_in, buf, 64);
+      memcpy(m_in32, buf, 64);
       if (m_need_byteswap)
       {
-         reverse_u32(m_in, 16);
+         reverse_u32(m_in8, 16);
       }
-      Transform(m_buf, (UINT32 *)m_in);
+      Transform(m_buf, m_in32);
       buf += 64;  // TODO: possible creation of out-of-bounds pointer 64 beyond end of data
       len -= 64;
    }
 
    // Save off any remaining bytes of data
-   memcpy(m_in, buf, len); // TODO: possible access beyond array
+   memcpy(m_in32, buf, len); // TODO: possible access beyond array
 } // MD5::Update
 
 
@@ -153,7 +154,7 @@ void MD5::Final(UINT8 digest[16])
     * Set the first char of padding to 0x80. This is safe since there is always
     * at least one byte free
     */
-   UINT8 *p = m_in + count;
+   UINT8 *p = m_in8 + count;
 
    *p++ = 0x80;
 
@@ -167,12 +168,12 @@ void MD5::Final(UINT8 digest[16])
       memset(p, 0, count);
       if (m_need_byteswap)
       {
-         reverse_u32(m_in, 16);
+         reverse_u32(m_in8, 16);
       }
-      Transform(m_buf, (UINT32 *)m_in);
+      Transform(m_buf, m_in32);
 
       // Now fill the next block with 56 bytes
-      memset(m_in, 0, 56);
+      memset(m_in32, 0, 56);
    }
    else
    {
@@ -181,14 +182,14 @@ void MD5::Final(UINT8 digest[16])
    }
    if (m_need_byteswap)
    {
-      reverse_u32(m_in, 14);
+      reverse_u32(m_in8, 14);
    }
 
    // Append length in bits and transform
-   memcpy(m_in + 56, &m_bits[0], 4);
-   memcpy(m_in + 60, &m_bits[1], 4);
+   memcpy(m_in8 + 56, &m_bits[0], 4);
+   memcpy(m_in8 + 60, &m_bits[1], 4);
 
-   Transform(m_buf, (UINT32 *)m_in);
+   Transform(m_buf, m_in32);
    if (m_need_byteswap)
    {
       reverse_u32((UINT8 *)m_buf, 4);
diff --git a/src/md5.h b/src/md5.h
index 69ed3df7..d1148b5e 100644
--- a/src/md5.h
+++ b/src/md5.h
@@ -65,7 +65,9 @@ public:
 private:
    UINT32 m_buf[4];
    UINT32 m_bits[2];
-   UINT8  m_in[64];
+   UINT32 m_in32[16];
+   // Alternate view of m_in32
+   UINT8  *m_in8;
    bool   m_need_byteswap;
    bool   m_big_endian;
 
-- 
2.17.1

